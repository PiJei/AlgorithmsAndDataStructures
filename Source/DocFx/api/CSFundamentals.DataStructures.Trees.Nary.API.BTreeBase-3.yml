### YamlMime:ManagedReference
items:
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  commentId: T:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  id: BTreeBase`3
  parent: CSFundamentals.DataStructures.Trees.Nary.API
  children:
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.#ctor(System.Int32)
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Build(System.Collections.Generic.Dictionary{`1,`2})
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Delete(`0,`1)
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Delete(`1)
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.FindLeafToInsertKey(`0,`1)
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetMaxNode(`0)
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetMinNode(`0)
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetSortedKeyValues(`0)
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Insert(System.Collections.Generic.KeyValuePair{`1,`2})
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.InsertInLeaf(`0,System.Collections.Generic.KeyValuePair{`1,`2})
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Join(`0,`0)
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.MaxBranchingDegree
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Root
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.RotateLeft(`0,`0,System.Int32)
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.RotateRight(`0,`0,System.Int32)
  - CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Search(`0,`1)
  langs:
  - csharp
  - vb
  name: BTreeBase<TNode, TKey, TValue>
  nameWithType: BTreeBase<TNode, TKey, TValue>
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>
  type: Class
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: BTreeBase
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 33
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nImplements base B-Tree\n"
  example: []
  syntax:
    content: >-
      public abstract class BTreeBase<TNode, TKey, TValue>

          where TNode : IBTreeNode<TNode, TKey, TValue>, IComparable<TNode> where TKey : IComparable<TKey>
    typeParameters:
    - id: TNode
      description: 'Type of the nodes stored in the tree. '
    - id: TKey
      description: 'Type of the keys stored in the tree. '
    - id: TValue
      description: 'Type of the values stored in the tree. '
    content.vb: Public MustInherit Class BTreeBase(Of TNode As {IBTreeNode(Of TNode, TKey, TValue), IComparable(Of TNode)}, TKey As IComparable(Of TKey), TValue)
  inheritance:
  - System.Object
  derivedClasses:
  - CSFundamentals.DataStructures.Trees.Nary.BPlusTree`2
  - CSFundamentals.DataStructures.Trees.Nary.BTree`2
  inheritedMembers:
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.ToString
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue)
  modifiers.csharp:
  - public
  - abstract
  - class
  modifiers.vb:
  - Public
  - MustInherit
  - Class
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue)
  name.vb: BTreeBase(Of TNode, TKey, TValue)
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Root
  commentId: F:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Root
  id: Root
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: Root
  nameWithType: BTreeBase<TNode, TKey, TValue>.Root
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.Root
  type: Field
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: Root
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 40
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nIs the root of the tree. \n"
  example: []
  syntax:
    content: public TNode Root
    return:
      type: '{TNode}'
    content.vb: Public Root As TNode
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).Root
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).Root
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.MaxBranchingDegree
  commentId: P:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.MaxBranchingDegree
  id: MaxBranchingDegree
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: MaxBranchingDegree
  nameWithType: BTreeBase<TNode, TKey, TValue>.MaxBranchingDegree
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.MaxBranchingDegree
  type: Property
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: MaxBranchingDegree
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 45
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nIs the maximum number of children for a non-leaf node in this B-Tree. \n"
  example: []
  syntax:
    content: public int MaxBranchingDegree { get; }
    parameters: []
    return:
      type: System.Int32
    content.vb: Public ReadOnly Property MaxBranchingDegree As Integer
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.MaxBranchingDegree*
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).MaxBranchingDegree
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).MaxBranchingDegree
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.#ctor(System.Int32)
  commentId: M:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: BTreeBase(Int32)
  nameWithType: BTreeBase<TNode, TKey, TValue>.BTreeBase(Int32)
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.BTreeBase(System.Int32)
  type: Constructor
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: .ctor
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 51
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nConstructor.\n"
  example: []
  syntax:
    content: public BTreeBase(int maxBranchingDegree)
    parameters:
    - id: maxBranchingDegree
      type: System.Int32
      description: 'Is the max branching degree or the max number of children a node in this tree can have. '
    content.vb: Public Sub New(maxBranchingDegree As Integer)
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.#ctor*
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).BTreeBase(Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).BTreeBase(System.Int32)
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Build(System.Collections.Generic.Dictionary{`1,`2})
  commentId: M:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Build(System.Collections.Generic.Dictionary{`1,`2})
  id: Build(System.Collections.Generic.Dictionary{`1,`2})
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: Build(Dictionary<TKey, TValue>)
  nameWithType: BTreeBase<TNode, TKey, TValue>.Build(Dictionary<TKey, TValue>)
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.Build(System.Collections.Generic.Dictionary<TKey, TValue>)
  type: Method
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: Build
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 61
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nGiven the set of key values, builds a b-tree by inserting all the key-value pairs. \n"
  example: []
  syntax:
    content: >-
      [TimeComplexity(Case.Best, "O(1)")]

      [TimeComplexity(Case.Worst, "O(nLog(n))")]

      [TimeComplexity(Case.Average, "O(n(Log(n))")]

      public TNode Build(Dictionary<TKey, TValue> keyValues)
    parameters:
    - id: keyValues
      type: System.Collections.Generic.Dictionary{{TKey},{TValue}}
      description: 'Is the list of key values to be inserted in the tree. '
    return:
      type: '{TNode}'
      description: 'Root of the tree. '
    content.vb: >-
      <TimeComplexity( Case.Best, "O(1)")>

      <TimeComplexity( Case.Worst, "O(nLog(n))")>

      <TimeComplexity( Case.Average, "O(n(Log(n))")>

      Public Function Build(keyValues As Dictionary(Of TKey, TValue)) As TNode
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Build*
  attributes:
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 1
    - type: System.String
      value: O(1)
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 2
    - type: System.String
      value: O(nLog(n))
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 0
    - type: System.String
      value: O(n(Log(n))
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).Build(Dictionary(Of TKey, TValue))
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).Build(System.Collections.Generic.Dictionary(Of TKey, TValue))
  name.vb: Build(Dictionary(Of TKey, TValue))
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Insert(System.Collections.Generic.KeyValuePair{`1,`2})
  commentId: M:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Insert(System.Collections.Generic.KeyValuePair{`1,`2})
  id: Insert(System.Collections.Generic.KeyValuePair{`1,`2})
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: Insert(KeyValuePair<TKey, TValue>)
  nameWithType: BTreeBase<TNode, TKey, TValue>.Insert(KeyValuePair<TKey, TValue>)
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.Insert(System.Collections.Generic.KeyValuePair<TKey, TValue>)
  type: Method
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: Insert
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 79
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nInserts a new key-value pair in the tree and returns root of the tree. \n"
  example: []
  syntax:
    content: >-
      [TimeComplexity(Case.Best, "O(1)", When = "Fist key in the tree is inserted.")]

      [TimeComplexity(Case.Worst, "O(D Log(n)(base:D)")]

      [TimeComplexity(Case.Average, "O(d Log(n)(base d))")]

      public TNode Insert(KeyValuePair<TKey, TValue> keyValue)
    parameters:
    - id: keyValue
      type: System.Collections.Generic.KeyValuePair{{TKey},{TValue}}
      description: 'Is the key-value pair to be inserted in the tree. '
    return:
      type: '{TNode}'
      description: 'Root of the tree. '
    content.vb: >-
      <TimeComplexity( Case.Best, "O(1)", When:="Fist key in the tree is inserted.")>

      <TimeComplexity( Case.Worst, "O(D Log(n)(base:D)")>

      <TimeComplexity( Case.Average, "O(d Log(n)(base d))")>

      Public Function Insert(keyValue As KeyValuePair(Of TKey, TValue)) As TNode
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Insert*
  attributes:
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 1
    - type: System.String
      value: O(1)
    namedArguments:
    - name: When
      type: System.String
      value: Fist key in the tree is inserted.
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 2
    - type: System.String
      value: O(D Log(n)(base:D)
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 0
    - type: System.String
      value: O(d Log(n)(base d))
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).Insert(KeyValuePair(Of TKey, TValue))
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).Insert(System.Collections.Generic.KeyValuePair(Of TKey, TValue))
  name.vb: Insert(KeyValuePair(Of TKey, TValue))
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Delete(`1)
  commentId: M:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Delete(`1)
  id: Delete(`1)
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: Delete(TKey)
  nameWithType: BTreeBase<TNode, TKey, TValue>.Delete(TKey)
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.Delete(TKey)
  type: Method
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: Delete
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 98
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nDeletes the given key from the tree if it exists. \n"
  example: []
  syntax:
    content: >-
      [TimeComplexity(Case.Best, "O(1)", When = "For example, there is only one key left in the tree.")]

      [TimeComplexity(Case.Worst, "O(D Log(n)(base D))")]

      [TimeComplexity(Case.Average, "O(d Log(n) base d)")]

      public bool Delete(TKey key)
    parameters:
    - id: key
      type: '{TKey}'
      description: 'The key to be deleted from the tree. '
    return:
      type: System.Boolean
      description: 'True in case of success, and false otherwise. '
    content.vb: >-
      <TimeComplexity( Case.Best, "O(1)", When:="For example, there is only one key left in the tree.")>

      <TimeComplexity( Case.Worst, "O(D Log(n)(base D))")>

      <TimeComplexity( Case.Average, "O(d Log(n) base d)")>

      Public Function Delete(key As TKey) As Boolean
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Delete*
  attributes:
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 1
    - type: System.String
      value: O(1)
    namedArguments:
    - name: When
      type: System.String
      value: For example, there is only one key left in the tree.
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 2
    - type: System.String
      value: O(D Log(n)(base D))
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 0
    - type: System.String
      value: O(d Log(n) base d)
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).Delete(TKey)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).Delete(TKey)
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.InsertInLeaf(`0,System.Collections.Generic.KeyValuePair{`1,`2})
  commentId: M:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.InsertInLeaf(`0,System.Collections.Generic.KeyValuePair{`1,`2})
  id: InsertInLeaf(`0,System.Collections.Generic.KeyValuePair{`1,`2})
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: InsertInLeaf(TNode, KeyValuePair<TKey, TValue>)
  nameWithType: BTreeBase<TNode, TKey, TValue>.InsertInLeaf(TNode, KeyValuePair<TKey, TValue>)
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.InsertInLeaf(TNode, System.Collections.Generic.KeyValuePair<TKey, TValue>)
  type: Method
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: InsertInLeaf
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 122
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nInserts the given key-value pair in the given leaf node. \n"
  example: []
  syntax:
    content: public abstract TNode InsertInLeaf(TNode leaf, KeyValuePair<TKey, TValue> keyValue)
    parameters:
    - id: leaf
      type: '{TNode}'
      description: 'A leaf node in the tree. '
    - id: keyValue
      type: System.Collections.Generic.KeyValuePair{{TKey},{TValue}}
      description: 'A key-value pair to be inserted in the tree. '
    return:
      type: '{TNode}'
      description: 'Root of the tree. '
    content.vb: Public MustOverride Function InsertInLeaf(leaf As TNode, keyValue As KeyValuePair(Of TKey, TValue)) As TNode
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.InsertInLeaf*
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).InsertInLeaf(TNode, KeyValuePair(Of TKey, TValue))
  modifiers.csharp:
  - public
  - abstract
  modifiers.vb:
  - Public
  - MustOverride
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).InsertInLeaf(TNode, System.Collections.Generic.KeyValuePair(Of TKey, TValue))
  name.vb: InsertInLeaf(TNode, KeyValuePair(Of TKey, TValue))
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Delete(`0,`1)
  commentId: M:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Delete(`0,`1)
  id: Delete(`0,`1)
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: Delete(TNode, TKey)
  nameWithType: BTreeBase<TNode, TKey, TValue>.Delete(TNode, TKey)
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.Delete(TNode, TKey)
  type: Method
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: Delete
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 130
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nDeletes the given key from the given node. \n"
  example: []
  syntax:
    content: public abstract bool Delete(TNode node, TKey key)
    parameters:
    - id: node
      type: '{TNode}'
      description: 'A node in the tree. '
    - id: key
      type: '{TKey}'
      description: 'A key in the tree. '
    return:
      type: System.Boolean
      description: 'True in case of success and false otherwise. '
    content.vb: Public MustOverride Function Delete(node As TNode, key As TKey) As Boolean
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Delete*
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).Delete(TNode, TKey)
  modifiers.csharp:
  - public
  - abstract
  modifiers.vb:
  - Public
  - MustOverride
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).Delete(TNode, TKey)
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetSortedKeyValues(`0)
  commentId: M:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetSortedKeyValues(`0)
  id: GetSortedKeyValues(`0)
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: GetSortedKeyValues(TNode)
  nameWithType: BTreeBase<TNode, TKey, TValue>.GetSortedKeyValues(TNode)
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.GetSortedKeyValues(TNode)
  type: Method
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: GetSortedKeyValues
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 137
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nGets the sorted list of all the key-values in the tree rooted at <code data-dev-comment-type=\"paramref\" class=\"paramref\">node</code>. \n"
  example: []
  syntax:
    content: public abstract List<KeyValuePair<TKey, TValue>> GetSortedKeyValues(TNode node)
    parameters:
    - id: node
      type: '{TNode}'
      description: ''
    return:
      type: System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{{TKey},{TValue}}}
      description: ''
    content.vb: Public MustOverride Function GetSortedKeyValues(node As TNode) As List(Of KeyValuePair(Of TKey, TValue))
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetSortedKeyValues*
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).GetSortedKeyValues(TNode)
  modifiers.csharp:
  - public
  - abstract
  modifiers.vb:
  - Public
  - MustOverride
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).GetSortedKeyValues(TNode)
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.FindLeafToInsertKey(`0,`1)
  commentId: M:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.FindLeafToInsertKey(`0,`1)
  id: FindLeafToInsertKey(`0,`1)
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: FindLeafToInsertKey(TNode, TKey)
  nameWithType: BTreeBase<TNode, TKey, TValue>.FindLeafToInsertKey(TNode, TKey)
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.FindLeafToInsertKey(TNode, TKey)
  type: Method
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: FindLeafToInsertKey
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 145
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nFinds a leaf node to insert a new given key. \n"
  example: []
  syntax:
    content: public abstract TNode FindLeafToInsertKey(TNode root, TKey key)
    parameters:
    - id: root
      type: '{TNode}'
      description: 'Is the node at which the tree is rooted. '
    - id: key
      type: '{TKey}'
      description: 'A new key to be inserted in the tree. '
    return:
      type: '{TNode}'
      description: 'Leaf node to insert the key. '
    content.vb: Public MustOverride Function FindLeafToInsertKey(root As TNode, key As TKey) As TNode
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.FindLeafToInsertKey*
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).FindLeafToInsertKey(TNode, TKey)
  modifiers.csharp:
  - public
  - abstract
  modifiers.vb:
  - Public
  - MustOverride
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).FindLeafToInsertKey(TNode, TKey)
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Search(`0,`1)
  commentId: M:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Search(`0,`1)
  id: Search(`0,`1)
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: Search(TNode, TKey)
  nameWithType: BTreeBase<TNode, TKey, TValue>.Search(TNode, TKey)
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.Search(TNode, TKey)
  type: Method
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: Search
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 153
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nSearches tree rooted at <code data-dev-comment-type=\"paramref\" class=\"paramref\">root</code> node for the given key. \n"
  example: []
  syntax:
    content: public abstract TNode Search(TNode root, TKey key)
    parameters:
    - id: root
      type: '{TNode}'
      description: 'The node at which tree is rooted. '
    - id: key
      type: '{TKey}'
      description: 'The key that is being searched. '
    return:
      type: '{TNode}'
      description: Tree node containing <code data-dev-comment-type="paramref" class="paramref">key</code>
    content.vb: Public MustOverride Function Search(root As TNode, key As TKey) As TNode
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Search*
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).Search(TNode, TKey)
  modifiers.csharp:
  - public
  - abstract
  modifiers.vb:
  - Public
  - MustOverride
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).Search(TNode, TKey)
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetMaxNode(`0)
  commentId: M:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetMaxNode(`0)
  id: GetMaxNode(`0)
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: GetMaxNode(TNode)
  nameWithType: BTreeBase<TNode, TKey, TValue>.GetMaxNode(TNode)
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.GetMaxNode(TNode)
  type: Method
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: GetMaxNode
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 160
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nFinds the node that contains the maximum key of the subtree rooted at node.\n"
  example: []
  syntax:
    content: >-
      [TimeComplexity(Case.Best, "O(1)", When = "when node is leaf.")]

      [TimeComplexity(Case.Worst, "O(Log(n))")]

      [TimeComplexity(Case.Average, "O(Log(n))")]

      public TNode GetMaxNode(TNode node)
    parameters:
    - id: node
      type: '{TNode}'
      description: 'The node at which (sub)tree is rooted. '
    return:
      type: '{TNode}'
      description: 'The node containing the maximum key of the (sub)tree rooted at <code data-dev-comment-type="paramref" class="paramref">node</code>. '
    content.vb: >-
      <TimeComplexity( Case.Best, "O(1)", When:="when node is leaf.")>

      <TimeComplexity( Case.Worst, "O(Log(n))")>

      <TimeComplexity( Case.Average, "O(Log(n))")>

      Public Function GetMaxNode(node As TNode) As TNode
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetMaxNode*
  attributes:
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 1
    - type: System.String
      value: O(1)
    namedArguments:
    - name: When
      type: System.String
      value: when node is leaf.
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 2
    - type: System.String
      value: O(Log(n))
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 0
    - type: System.String
      value: O(Log(n))
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).GetMaxNode(TNode)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).GetMaxNode(TNode)
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetMinNode(`0)
  commentId: M:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetMinNode(`0)
  id: GetMinNode(`0)
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: GetMinNode(TNode)
  nameWithType: BTreeBase<TNode, TKey, TValue>.GetMinNode(TNode)
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.GetMinNode(TNode)
  type: Method
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: GetMinNode
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 178
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nFinds the node that contains the minimum key of the subtree rooted at <code data-dev-comment-type=\"paramref\" class=\"paramref\">node</code>.\n"
  example: []
  syntax:
    content: public TNode GetMinNode(TNode node)
    parameters:
    - id: node
      type: '{TNode}'
      description: The node at which (sub)tree is rooted.
    return:
      type: '{TNode}'
      description: The node containing the minimum key of the (sub)tree rooted at <code data-dev-comment-type="paramref" class="paramref">node</code>.
    content.vb: Public Function GetMinNode(node As TNode) As TNode
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetMinNode*
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).GetMinNode(TNode)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).GetMinNode(TNode)
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.RotateLeft(`0,`0,System.Int32)
  commentId: M:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.RotateLeft(`0,`0,System.Int32)
  id: RotateLeft(`0,`0,System.Int32)
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: RotateLeft(TNode, TNode, Int32)
  nameWithType: BTreeBase<TNode, TKey, TValue>.RotateLeft(TNode, TNode, Int32)
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.RotateLeft(TNode, TNode, System.Int32)
  type: Method
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: RotateLeft
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 194
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nRotates a key from the right sibling of the node via their parent to the node. \nThe cost of this operation is at inserting keys and children, in right position (to preserve order), Which at worst is O(K), Where K is the maximum number of keys in a node, and thus is constant. \n"
  example: []
  syntax:
    content: >-
      [TimeComplexity(Case.Best, "O(1)")]

      [TimeComplexity(Case.Worst, "O(K)")]

      [TimeComplexity(Case.Average, "O(K)")]

      public TNode RotateLeft(TNode node, TNode rightSibling, int separatorIndex)
    parameters:
    - id: node
      type: '{TNode}'
      description: 'Is the receiver of a new key. '
    - id: rightSibling
      type: '{TNode}'
      description: 'The node that lends a key to the process. This key moves to parent, and a key from parent moves to node. '
    - id: separatorIndex
      type: System.Int32
      description: 'The index of the key separating <code data-dev-comment-type="paramref" class="paramref">node</code> and <code data-dev-comment-type="paramref" class="paramref">rightSibling</code> in the parent children array. '
    return:
      type: '{TNode}'
    content.vb: >-
      <TimeComplexity( Case.Best, "O(1)")>

      <TimeComplexity( Case.Worst, "O(K)")>

      <TimeComplexity( Case.Average, "O(K)")>

      Public Function RotateLeft(node As TNode, rightSibling As TNode, separatorIndex As Integer) As TNode
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.RotateLeft*
  attributes:
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 1
    - type: System.String
      value: O(1)
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 2
    - type: System.String
      value: O(K)
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 0
    - type: System.String
      value: O(K)
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).RotateLeft(TNode, TNode, Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).RotateLeft(TNode, TNode, System.Int32)
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.RotateRight(`0,`0,System.Int32)
  commentId: M:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.RotateRight(`0,`0,System.Int32)
  id: RotateRight(`0,`0,System.Int32)
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: RotateRight(TNode, TNode, Int32)
  nameWithType: BTreeBase<TNode, TKey, TValue>.RotateRight(TNode, TNode, Int32)
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.RotateRight(TNode, TNode, System.Int32)
  type: Method
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: RotateRight
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 228
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nRotates a key from the left sibling of the node via their parent to the node.\nThe cost of this operation is at inserting keys and children, in right position (to preserve order), Which at worst is O(K), Where K is the maximum number of keys in a node, and thus is constant. \n"
  example: []
  syntax:
    content: >-
      [TimeComplexity(Case.Best, "O(1)")]

      [TimeComplexity(Case.Worst, "O(K)")]

      [TimeComplexity(Case.Average, "O(K)")]

      public TNode RotateRight(TNode node, TNode leftSibling, int separatorIndex)
    parameters:
    - id: node
      type: '{TNode}'
      description: 'Is the receiver of a new key. '
    - id: leftSibling
      type: '{TNode}'
      description: The node that lends a key to the process. This key moves to parent, and a key from parent moves to node.
    - id: separatorIndex
      type: System.Int32
      description: 'The index of the key separating <code data-dev-comment-type="paramref" class="paramref">node</code> and <code data-dev-comment-type="paramref" class="paramref">leftSibling</code> in the parent children array. '
    return:
      type: '{TNode}'
    content.vb: >-
      <TimeComplexity( Case.Best, "O(1)")>

      <TimeComplexity( Case.Worst, "O(K)")>

      <TimeComplexity( Case.Average, "O(K)")>

      Public Function RotateRight(node As TNode, leftSibling As TNode, separatorIndex As Integer) As TNode
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.RotateRight*
  attributes:
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 1
    - type: System.String
      value: O(1)
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 2
    - type: System.String
      value: O(K)
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 0
    - type: System.String
      value: O(K)
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).RotateRight(TNode, TNode, Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).RotateRight(TNode, TNode, System.Int32)
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Join(`0,`0)
  commentId: M:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Join(`0,`0)
  id: Join(`0,`0)
  parent: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3
  langs:
  - csharp
  - vb
  name: Join(TNode, TNode)
  nameWithType: BTreeBase<TNode, TKey, TValue>.Join(TNode, TNode)
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.Join(TNode, TNode)
  type: Method
  source:
    remote:
      path: Source/DataStructures/Trees/Nary/API/BTreeBase.cs
      branch: dev/pijei/AddingDocFx
      repo: https://github.com/PiJei/CSFundamentalAlgorithms.git
    id: Join
    path: ../DataStructures/Trees/Nary/API/BTreeBase.cs
    startLine: 261
  assemblies:
  - CSFundamentals
  namespace: CSFundamentals.DataStructures.Trees.Nary.API
  summary: "\nMerges node with its left sibling, such that node can be dropped. Also borrows a key from parent. \n"
  example: []
  syntax:
    content: >-
      [TimeComplexity(Case.Best, "O(1)")]

      [TimeComplexity(Case.Worst, "O(K)")]

      [TimeComplexity(Case.Average, "O(K)")]

      public TNode Join(TNode node, TNode leftSibling)
    parameters:
    - id: node
      type: '{TNode}'
      description: 'The node that will be dissolved at the end of operation. '
    - id: leftSibling
      type: '{TNode}'
      description: 'The node that will contain keys of the node, its current keys, and a key from parent. '
    return:
      type: '{TNode}'
      description: 'Parent of the nodes. '
    content.vb: >-
      <TimeComplexity( Case.Best, "O(1)")>

      <TimeComplexity( Case.Worst, "O(K)")>

      <TimeComplexity( Case.Average, "O(K)")>

      Public Function Join(node As TNode, leftSibling As TNode) As TNode
  overload: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Join*
  attributes:
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 1
    - type: System.String
      value: O(1)
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 2
    - type: System.String
      value: O(K)
  - type: CSFundamentals.Decoration.TimeComplexityAttribute
    ctor: CSFundamentals.Decoration.TimeComplexityAttribute.#ctor(CSFundamentals.Decoration.Case,System.String)
    arguments:
    - type: CSFundamentals.Decoration.Case
      value: 0
    - type: System.String
      value: O(K)
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).Join(TNode, TNode)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).Join(TNode, TNode)
references:
- uid: CSFundamentals.DataStructures.Trees.Nary.API
  commentId: N:CSFundamentals.DataStructures.Trees.Nary.API
  name: CSFundamentals.DataStructures.Trees.Nary.API
  nameWithType: CSFundamentals.DataStructures.Trees.Nary.API
  fullName: CSFundamentals.DataStructures.Trees.Nary.API
- uid: System.Object
  commentId: T:System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Object.Equals(System.Object)
  commentId: M:System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  nameWithType: Object.Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  commentId: M:System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  nameWithType: Object.Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.GetHashCode
  commentId: M:System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  nameWithType: Object.GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    nameWithType: Object.GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    nameWithType: Object.GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.GetType
  commentId: M:System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  nameWithType: Object.GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    nameWithType: Object.GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    nameWithType: Object.GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.MemberwiseClone
  commentId: M:System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  nameWithType: Object.MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    nameWithType: Object.MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    nameWithType: Object.MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  nameWithType: Object.ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    nameWithType: Object.ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    nameWithType: Object.ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.ToString
  commentId: M:System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  nameWithType: Object.ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    nameWithType: Object.ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    nameWithType: Object.ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System
  commentId: N:System
  isExternal: true
  name: System
  nameWithType: System
  fullName: System
- uid: '{TNode}'
  commentId: '!:TNode'
  definition: TNode
  name: TNode
  nameWithType: TNode
  fullName: TNode
- uid: TNode
  name: TNode
  nameWithType: TNode
  fullName: TNode
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.MaxBranchingDegree*
  commentId: Overload:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.MaxBranchingDegree
  name: MaxBranchingDegree
  nameWithType: BTreeBase<TNode, TKey, TValue>.MaxBranchingDegree
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.MaxBranchingDegree
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).MaxBranchingDegree
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).MaxBranchingDegree
- uid: System.Int32
  commentId: T:System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.#ctor*
  commentId: Overload:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.#ctor
  name: BTreeBase
  nameWithType: BTreeBase<TNode, TKey, TValue>.BTreeBase
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.BTreeBase
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).BTreeBase
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).BTreeBase
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Build*
  commentId: Overload:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Build
  name: Build
  nameWithType: BTreeBase<TNode, TKey, TValue>.Build
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.Build
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).Build
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).Build
- uid: System.Collections.Generic.Dictionary{{TKey},{TValue}}
  commentId: T:System.Collections.Generic.Dictionary{`1,`2}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.Dictionary`2
  name: Dictionary<TKey, TValue>
  nameWithType: Dictionary<TKey, TValue>
  fullName: System.Collections.Generic.Dictionary<TKey, TValue>
  nameWithType.vb: Dictionary(Of TKey, TValue)
  fullName.vb: System.Collections.Generic.Dictionary(Of TKey, TValue)
  name.vb: Dictionary(Of TKey, TValue)
  spec.csharp:
  - uid: System.Collections.Generic.Dictionary`2
    name: Dictionary
    nameWithType: Dictionary
    fullName: System.Collections.Generic.Dictionary
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TKey
    nameWithType: TKey
    fullName: TKey
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TValue
    nameWithType: TValue
    fullName: TValue
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.Dictionary`2
    name: Dictionary
    nameWithType: Dictionary
    fullName: System.Collections.Generic.Dictionary
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TKey
    nameWithType: TKey
    fullName: TKey
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TValue
    nameWithType: TValue
    fullName: TValue
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.Dictionary`2
  commentId: T:System.Collections.Generic.Dictionary`2
  isExternal: true
  name: Dictionary<TKey, TValue>
  nameWithType: Dictionary<TKey, TValue>
  fullName: System.Collections.Generic.Dictionary<TKey, TValue>
  nameWithType.vb: Dictionary(Of TKey, TValue)
  fullName.vb: System.Collections.Generic.Dictionary(Of TKey, TValue)
  name.vb: Dictionary(Of TKey, TValue)
  spec.csharp:
  - uid: System.Collections.Generic.Dictionary`2
    name: Dictionary
    nameWithType: Dictionary
    fullName: System.Collections.Generic.Dictionary
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TKey
    nameWithType: TKey
    fullName: TKey
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TValue
    nameWithType: TValue
    fullName: TValue
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.Dictionary`2
    name: Dictionary
    nameWithType: Dictionary
    fullName: System.Collections.Generic.Dictionary
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TKey
    nameWithType: TKey
    fullName: TKey
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TValue
    nameWithType: TValue
    fullName: TValue
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic
  commentId: N:System.Collections.Generic
  isExternal: true
  name: System.Collections.Generic
  nameWithType: System.Collections.Generic
  fullName: System.Collections.Generic
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Insert*
  commentId: Overload:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Insert
  name: Insert
  nameWithType: BTreeBase<TNode, TKey, TValue>.Insert
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.Insert
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).Insert
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).Insert
- uid: System.Collections.Generic.KeyValuePair{{TKey},{TValue}}
  commentId: T:System.Collections.Generic.KeyValuePair{`0,`1}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.KeyValuePair`2
  name: KeyValuePair<TKey, TValue>
  nameWithType: KeyValuePair<TKey, TValue>
  fullName: System.Collections.Generic.KeyValuePair<TKey, TValue>
  nameWithType.vb: KeyValuePair(Of TKey, TValue)
  fullName.vb: System.Collections.Generic.KeyValuePair(Of TKey, TValue)
  name.vb: KeyValuePair(Of TKey, TValue)
  spec.csharp:
  - uid: System.Collections.Generic.KeyValuePair`2
    name: KeyValuePair
    nameWithType: KeyValuePair
    fullName: System.Collections.Generic.KeyValuePair
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TKey
    nameWithType: TKey
    fullName: TKey
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TValue
    nameWithType: TValue
    fullName: TValue
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.KeyValuePair`2
    name: KeyValuePair
    nameWithType: KeyValuePair
    fullName: System.Collections.Generic.KeyValuePair
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TKey
    nameWithType: TKey
    fullName: TKey
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TValue
    nameWithType: TValue
    fullName: TValue
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.KeyValuePair`2
  commentId: T:System.Collections.Generic.KeyValuePair`2
  isExternal: true
  name: KeyValuePair<TKey, TValue>
  nameWithType: KeyValuePair<TKey, TValue>
  fullName: System.Collections.Generic.KeyValuePair<TKey, TValue>
  nameWithType.vb: KeyValuePair(Of TKey, TValue)
  fullName.vb: System.Collections.Generic.KeyValuePair(Of TKey, TValue)
  name.vb: KeyValuePair(Of TKey, TValue)
  spec.csharp:
  - uid: System.Collections.Generic.KeyValuePair`2
    name: KeyValuePair
    nameWithType: KeyValuePair
    fullName: System.Collections.Generic.KeyValuePair
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TKey
    nameWithType: TKey
    fullName: TKey
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TValue
    nameWithType: TValue
    fullName: TValue
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.KeyValuePair`2
    name: KeyValuePair
    nameWithType: KeyValuePair
    fullName: System.Collections.Generic.KeyValuePair
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TKey
    nameWithType: TKey
    fullName: TKey
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TValue
    nameWithType: TValue
    fullName: TValue
  - name: )
    nameWithType: )
    fullName: )
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Delete*
  commentId: Overload:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Delete
  name: Delete
  nameWithType: BTreeBase<TNode, TKey, TValue>.Delete
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.Delete
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).Delete
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).Delete
- uid: '{TKey}'
  commentId: '!:TKey'
  definition: TKey
  name: TKey
  nameWithType: TKey
  fullName: TKey
- uid: System.Boolean
  commentId: T:System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: TKey
  name: TKey
  nameWithType: TKey
  fullName: TKey
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.InsertInLeaf*
  commentId: Overload:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.InsertInLeaf
  name: InsertInLeaf
  nameWithType: BTreeBase<TNode, TKey, TValue>.InsertInLeaf
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.InsertInLeaf
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).InsertInLeaf
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).InsertInLeaf
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetSortedKeyValues*
  commentId: Overload:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetSortedKeyValues
  name: GetSortedKeyValues
  nameWithType: BTreeBase<TNode, TKey, TValue>.GetSortedKeyValues
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.GetSortedKeyValues
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).GetSortedKeyValues
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).GetSortedKeyValues
- uid: System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{{TKey},{TValue}}}
  commentId: T:System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{`0,`1}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.List`1
  name: List<KeyValuePair<TKey, TValue>>
  nameWithType: List<KeyValuePair<TKey, TValue>>
  fullName: System.Collections.Generic.List<System.Collections.Generic.KeyValuePair<TKey, TValue>>
  nameWithType.vb: List(Of KeyValuePair(Of TKey, TValue))
  fullName.vb: System.Collections.Generic.List(Of System.Collections.Generic.KeyValuePair(Of TKey, TValue))
  name.vb: List(Of KeyValuePair(Of TKey, TValue))
  spec.csharp:
  - uid: System.Collections.Generic.List`1
    name: List
    nameWithType: List
    fullName: System.Collections.Generic.List
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Collections.Generic.KeyValuePair`2
    name: KeyValuePair
    nameWithType: KeyValuePair
    fullName: System.Collections.Generic.KeyValuePair
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TKey
    nameWithType: TKey
    fullName: TKey
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TValue
    nameWithType: TValue
    fullName: TValue
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.List`1
    name: List
    nameWithType: List
    fullName: System.Collections.Generic.List
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Collections.Generic.KeyValuePair`2
    name: KeyValuePair
    nameWithType: KeyValuePair
    fullName: System.Collections.Generic.KeyValuePair
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TKey
    nameWithType: TKey
    fullName: TKey
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TValue
    nameWithType: TValue
    fullName: TValue
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.List`1
  commentId: T:System.Collections.Generic.List`1
  isExternal: true
  name: List<T>
  nameWithType: List<T>
  fullName: System.Collections.Generic.List<T>
  nameWithType.vb: List(Of T)
  fullName.vb: System.Collections.Generic.List(Of T)
  name.vb: List(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.List`1
    name: List
    nameWithType: List
    fullName: System.Collections.Generic.List
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.List`1
    name: List
    nameWithType: List
    fullName: System.Collections.Generic.List
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.FindLeafToInsertKey*
  commentId: Overload:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.FindLeafToInsertKey
  name: FindLeafToInsertKey
  nameWithType: BTreeBase<TNode, TKey, TValue>.FindLeafToInsertKey
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.FindLeafToInsertKey
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).FindLeafToInsertKey
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).FindLeafToInsertKey
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Search*
  commentId: Overload:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Search
  name: Search
  nameWithType: BTreeBase<TNode, TKey, TValue>.Search
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.Search
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).Search
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).Search
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetMaxNode*
  commentId: Overload:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetMaxNode
  name: GetMaxNode
  nameWithType: BTreeBase<TNode, TKey, TValue>.GetMaxNode
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.GetMaxNode
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).GetMaxNode
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).GetMaxNode
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetMinNode*
  commentId: Overload:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.GetMinNode
  name: GetMinNode
  nameWithType: BTreeBase<TNode, TKey, TValue>.GetMinNode
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.GetMinNode
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).GetMinNode
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).GetMinNode
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.RotateLeft*
  commentId: Overload:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.RotateLeft
  name: RotateLeft
  nameWithType: BTreeBase<TNode, TKey, TValue>.RotateLeft
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.RotateLeft
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).RotateLeft
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).RotateLeft
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.RotateRight*
  commentId: Overload:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.RotateRight
  name: RotateRight
  nameWithType: BTreeBase<TNode, TKey, TValue>.RotateRight
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.RotateRight
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).RotateRight
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).RotateRight
- uid: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Join*
  commentId: Overload:CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase`3.Join
  name: Join
  nameWithType: BTreeBase<TNode, TKey, TValue>.Join
  fullName: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase<TNode, TKey, TValue>.Join
  nameWithType.vb: BTreeBase(Of TNode, TKey, TValue).Join
  fullName.vb: CSFundamentals.DataStructures.Trees.Nary.API.BTreeBase(Of TNode, TKey, TValue).Join
